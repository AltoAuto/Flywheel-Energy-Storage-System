function result = simulate_cycle(p, geom, t, P_cmd)
%SIMULATE_CYCLE  Simulate flywheel SoC, speed, losses, and rotor temperature over a cycle.
%
%   result = simulate_cycle(p, geom, t, P_cmd)
%
% Inputs:
%   p     - parameter struct from params()
%   geom  - geometry struct (compute_geometry + compute_inertia)
%   t     - time vector [s]
%   P_cmd - commanded power [W]
%           Convention (assumed & documented):
%             P_cmd > 0 : flywheel delivers power to grid (discharge)
%             P_cmd < 0 : flywheel absorbs power from grid (charge)
%
% Outputs (in struct 'result'):
%   .t           - time vector [s]
%   .omega       - rotor speed [rad/s]
%   .soc         - state-of-charge [0..1]
%   .P_cmd       - commanded power [W]
%   .P_rotor     - rotor losses [W]
%   .P_stator    - stator losses [W]
%   .P_total     - total EM losses [W]
%   .T_rotor     - rotor temperature [K]
%
% Modeling notes:
%   - Dynamics:
%       J * omega * domega/dt = -P_cmd - P_rotor
%     (energy-based: P_cmd is power to grid, P_rotor is rotor dissipation)
%
%   - Current / torque for EE losses:
%       T_demand = P_cmd / omega
%       T_oper   = saturate(T_demand, ±T_rated)
%       I_pu     = T_oper / T_rated
%     where T_rated comes from the provided electric machine parameter file.
%
%   - Temperature:
%       compute_temperature(p, geom, P_rotor)
%     using your radiation-only rotor thermal model.

    % -------------------------
    % Basic input checks
    % -------------------------
    if numel(t) ~= numel(P_cmd)
        error('simulate_cycle:SizeMismatch', ...
              't and P_cmd must have the same length.');
    end

    t     = t(:);        % ensure column
    P_cmd = P_cmd(:);    % ensure column
    N  = numel(t);

    % -------------------------
    % Time step check
    % -------------------------
    if N < 2
        error('simulate_cycle:TooShort', 'Need at least 2 time points.');
    end
    dt = diff(t);
    if any(abs(dt - dt(1)) > 1e-9)
        warning('simulate_cycle:NonuniformDt', ...
                'Non-uniform dt detected; using local dt per step.');
    end

    % -------------------------
    % Rotor inertia
    % -------------------------
    J = geom.J_total;

    % -------------------------
    % Load REAL motor rated torque from machine parameters
    % -------------------------
    % Adjust this function name to match the actual file you were given:
    %   e.g. elecMachineParameters(), baselineMachineParams(), etc.
    mp = elecMachineParams(); 

    % Extract rated torque field (you MUST adjust this based on real struct)
    if isfield(mp, 'rated_torque_Nm')
        T_rated = mp.rated_torque_Nm;
    elseif isfield(mp, 'ratedTorque')
        T_rated = mp.ratedTorque;
    elseif isfield(mp, 'T_rated')
        T_rated = mp.T_rated;
    else
        error('simulate_cycle:NoRatedTorque', ...
              ['Rated torque field not found in machine parameter struct.\n' ...
               'Check elecMachineParams.m and update simulate_cycle.m to use the correct field name.']);
    end

    if T_rated <= 0
        error('simulate_cycle:BadRatedTorque', ...
              'Rated torque T_rated must be > 0.');
    end

    % -------------------------
    % Preallocate arrays
    % -------------------------
    omega    = zeros(N,1);
    soc      = zeros(N,1);
    P_rotor  = zeros(N,1);
    P_stator = zeros(N,1);
    P_total  = zeros(N,1);
    T_rot    = zeros(N,1);

    % -------------------------
    % Initial condition: start at initial SoC
    % -------------------------
    soc0   = p.initial_state_of_charge_frac;   % usually 0.5
    omega0 = compute_soc('soc2omega', soc0, p, geom);

    omega(1) = omega0;
    soc(1)   = soc0;

    % -------------------------
    % Time stepping loop
    % -------------------------
    for k = 1:N-1
        dt_k      = t(k+1) - t(k);
        omega_k   = omega(k);
        Pk        = P_cmd(k);

        % Avoid division by zero
        omega_safe = max(omega_k, 1e-3);

        % -------------------------
        % Torque demand from power
        % -------------------------
        % Pk is power delivered to grid (positive = discharge).
        % Mechanical torque magnitude required at this speed:
        T_demand = Pk / omega_safe;   % [N·m], can be positive or negative

        % Saturate torque at ±T_rated (motor limit)
        if T_demand > T_rated
            T_oper = T_rated;
        elseif T_demand < -T_rated
            T_oper = -T_rated;
        else
            T_oper = T_demand;
        end

        % Per-unit current: torque relative to rated torque
        I_pu = T_oper / T_rated;   % dimensionless, typically in [-1, 1]

        % -------------------------
        % EE losses at this step
        % -------------------------
        [P_tot_k, P_rot_k, P_stat_k, ~, ~] = ...
            compute_losses(p, geom, I_pu, omega_safe);

        P_rotor(k)  = P_rot_k;
        P_stator(k) = P_stat_k;
        P_total(k)  = P_tot_k;

        % Rotor temperature from *rotor* losses only (radiation model)
        T_rot(k) = compute_temperature(p, geom, P_rot_k);

        % -------------------------
        % Rotor dynamics (energy-based)
        % -------------------------
        % Energy balance on rotor:
        %   J * omega * domega/dt = -P_cmd - P_rotor
        % where:
        %   P_cmd  > 0 : power out of rotor (discharge)
        %   P_rotor     : power dissipated in rotor
        domega_dt = (-Pk - P_rot_k) / (J * omega_safe);

        omega_next = omega_k + domega_dt * dt_k;
        omega_next = max(0, omega_next);   % no negative speed

        omega(k+1) = omega_next;

        % Update SoC from new speed
        soc(k+1) = compute_soc('omega2soc', omega_next, p, geom);
    end

    % For the last time point, reuse the last computed losses/temperature
    P_rotor(end)  = P_rotor(end-1);
    P_stator(end) = P_stator(end-1);
    P_total(end)  = P_total(end-1);
    T_rot(end)    = T_rot(end-1);

    % -------------------------
    % Pack results
    % -------------------------
    result = struct();
    result.t        = t;
    result.omega    = omega;
    result.soc      = soc;
    result.P_cmd    = P_cmd;
    result.P_rotor  = P_rotor;
    result.P_stator = P_stator;
    result.P_total  = P_total;
    result.T_rotor  = T_rot;

end
